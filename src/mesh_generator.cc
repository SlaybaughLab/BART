#include <deal.II/grid/grid_generator.h>
#include <deal.II/grid/grid_tools.h>
#include <deal.II/grid/tria_accessor.h>
#include <deal.II/grid/tria_iterator.h>
#include <deal.II/grid/grid_in.h>

#include <fstream>

#include "../include/mesh_generator.h"

template <int dim>
MeshGenerator<dim>::MeshGenerator (ParameterHandler &prm)
:
is_mesh_generated(prm.get_bool("is mesh generated by deal.II")),
have_reflective_bc(prm.get_bool("have reflective BC")),
global_refinements(prm.get_integer("uniform refinements"))
{
  if (!is_mesh_generated)
    mesh_filename = prm.get ("mesh file name");
  else
  {
    process_coordinate_information (prm);
    initialize_relative_position_to_id_map (prm);
    preprocess_reflective_bc (prm);
  }
}

template <int dim>
MeshGenerator<dim>::~MeshGenerator ()
{
}

template <int dim>
void MeshGenerator<dim>::make_grid (Triangulation<dim> &tria)
{
  if (is_mesh_generated)
  {
    generate_initial_grid (tria);
    initialize_material_id (tria);
    setup_boundary_ids (tria);
    tria.refine_global (global_refinements);
  }
  else
  {
    GridIn<dim> gi;
    gi.attach_triangulation (tria);
    std::ifstream f(mesh_filename);
    gi.read_msh (f);
  }
}

template <int dim>
void MeshGenerator<dim>::generate_initial_grid (Triangulation<dim> &tria)
{
  Point<dim> origin;
  Point<dim> diagonal;
  switch (dim)
  {
    case 1:
    {
      diagonal[0] = axis_max_values[0];
      break;
    }
      
    case 2:
    {
      diagonal[0] = axis_max_values[0];
      diagonal[1] = axis_max_values[1];
      break;
    }
      
    case 3:
    {
      diagonal[0] = axis_max_values[0];
      diagonal[1] = axis_max_values[1];
      diagonal[2] = axis_max_values[2];
      break;
    }
      
    default:
      break;
  }
  GridGenerator::subdivided_hyper_rectangle (tria,
                                             ncell_per_dir,
                                             origin,
                                             diagonal);
}

template <int dim>
void MeshGenerator<dim>::initialize_material_id (Triangulation<dim> &tria)
{
  AssertThrow (is_mesh_generated==true,
               ExcMessage("mesh read in have to have boundary ids associated"));
  for (auto cell=tria.begin_active();
       cell!=tria.end(); ++cell)
    if (cell->is_locally_owned())
    {
      Point<dim> center = cell->center ();
      std::vector<unsigned int> relative_position (3);
      get_cell_relative_position (center, relative_position);
      unsigned int material_id = relative_position_to_id[relative_position];
      cell->set_material_id (material_id);
    }
}

template <int dim>
void MeshGenerator<dim>::get_cell_relative_position (Point<dim> &center,
                                                     std::vector<unsigned int> &relative_position)
{
  AssertThrow (relative_position.size()==3,
               ExcMessage("relative position should be size 3 for any dimension"));
  if (dim>=1)
  {
    relative_position[0] = static_cast<unsigned int>(center[0] / cell_size_all_dir[0]);
    if (dim>=2)
    {
      relative_position[1] = static_cast<unsigned int>(center[1] / cell_size_all_dir[1]);
      if (dim==3)
        relative_position[2] = static_cast<unsigned int>(center[2] / cell_size_all_dir[2]);
    }
  }
}

template <int dim>
void MeshGenerator<dim>::setup_boundary_ids (Triangulation<dim> &tria)
{
  AssertThrow (is_mesh_generated==true,
               ExcMessage("mesh read in have to have boundary ids associated"));
  AssertThrow (axis_max_values.size()==dim,
               ExcMessage("number of entries axis max values should be dimension"));
  
  for (auto cell=tria.begin_active();
       cell!=tria.end(); ++cell)
  {
    if (cell->is_locally_owned())
    {
      for (unsigned int fn=0; fn<GeometryInfo<dim>::faces_per_cell; ++fn)
      {
        if (cell->face(fn)->at_boundary())
        {
          Point<dim> ct = cell->face(fn)->center();
          // left boundary
          if (std::fabs(ct[0])<1.0e-14)
            cell->face(fn)->set_boundary_id (0);
          
          // right boundary
          if (std::fabs(ct[0]-axis_max_values[0])<1.0e-14)
            cell->face(fn)->set_boundary_id (1);
          
          // 2D and 3D boundaries
          if (dim>1)
          {
            // 2D boundaries
            // front boundary
            if (std::fabs(ct[1])<1.0e-14)
              cell->face(fn)->set_boundary_id (2);
            
            // rear boundary
            if (std::fabs(ct[1]-axis_max_values[1])<1.0e-14)
              cell->face(fn)->set_boundary_id (3);
            
            // 3D boundaries
            if (dim>2)
            {
              // front boundary
              if (std::fabs(ct[2])<1.0e-14)
                cell->face(fn)->set_boundary_id (4);
              
              // rear boundary
              if (std::fabs(ct[2]-axis_max_values[2])<1.0e-14)
                cell->face(fn)->set_boundary_id (5);
            }
          }
        }
      }// face
    }// locally owned cell
  }// cell
}

template <int dim>
void MeshGenerator<dim>::process_coordinate_information (ParameterHandler &prm)
{
  AssertThrow (dim>1,
               ExcMessage("1D is not implemented."));
  // max values for all axis
  std::vector<std::string> strings = Utilities::split_string_list (prm.get ("x, y, z max values of boundary locations"));
  AssertThrow (strings.size()>=dim,
               ExcMessage("Number of axis max values must be the same as dimension"));
  for (unsigned int i=0; i<dim; ++i)
    axis_max_values.push_back (std::atof (strings[i].c_str()));
  
  // read in number of cells and get cell sizes along axes
  strings = Utilities::split_string_list (prm.get ("number of cells for x, y, z directions"));
  AssertThrow (strings.size()>=dim,
               ExcMessage ("Entries for numbers of cells should be equal to dimension"));
  std::vector<unsigned int> cells_per_dir;
  std::vector<std::vector<double> > spacings;
  for (unsigned int d=0; d<dim; ++d)
  {
    ncell_per_dir.push_back (std::atoi (strings[d].c_str ()));
    cell_size_all_dir.push_back (axis_max_values[d]/ncell_per_dir[d]);
  }
}

template <int dim>
void MeshGenerator<dim>::preprocess_reflective_bc (ParameterHandler &prm)
{
  if (have_reflective_bc)
  {
    std::map<std::string, unsigned int> bd_names_to_id
    {{"xmin",0}, {"xmax",1}, {"ymin",2}, {"ymax",3}, {"zmin",4}, {"zmax",5}};
    std::vector<std::string> strings = Utilities::split_string_list (prm.get ("reflective boundary names"));
    AssertThrow (strings.size()>0,
                 ExcMessage("reflective boundary names have to be entered"));
    std::set<int> tmp;
    for (unsigned int i=0; i<strings.size (); ++i)
    {
      AssertThrow(bd_names_to_id.find(strings[i])!=bd_names_to_id.end(),
                  ExcMessage("Invalid reflective boundary name: use xmin, xmax, etc."));
      tmp.insert (bd_names_to_id[strings[i]]);
    }
    auto it = tmp.begin ();
    std::ostringstream os;
    os << "No valid reflective boundary name for " << dim << "D";
    AssertThrow(*it<2*dim,
                ExcMessage(os.str()));
    for (unsigned int i=0; i<2*dim; ++i)
    {
      if (tmp.count (i))
        is_reflective_bc[i] = true;
      else
        is_reflective_bc[i] = false;
    }
  }
}

template <int dim>
void MeshGenerator<dim>::get_relevant_cell_iterators
(DoFHandler<dim> &dof_handler,
 std::vector<typename DoFHandler<dim>::active_cell_iterator> &local_cells,
 std::vector<bool> &is_cell_at_bd,
 std::vector<bool> &is_cell_at_ref_bd)
{
  for (typename DoFHandler<dim>::active_cell_iterator
       cell=dof_handler.begin_active();
       cell!=dof_handler.end(); ++cell)
    if (cell->is_locally_owned())
    {
      local_cells.push_back (cell);
      if (cell->at_boundary())
        is_cell_at_bd.push_back (true);
      else
        is_cell_at_bd.push_back (false);
      
      if (have_reflective_bc)
      {
        bool at_ref_bd = false;
        for (unsigned int fn=0; fn<GeometryInfo<dim>::faces_per_cell; ++fn)
          if (cell->at_boundary(fn))
          {
            unsigned int bd_id = cell->face(fn)->boundary_id ();
            if (!at_ref_bd && is_reflective_bc[bd_id])
              at_ref_bd = true;
          }
        if (at_ref_bd)
          is_cell_at_ref_bd.push_back (true);
        else
          is_cell_at_ref_bd.push_back (false);
      }
    }
}

template <int dim>
void MeshGenerator<dim>::initialize_relative_position_to_id_map (ParameterHandler &prm)
{
  prm.enter_subsection ("material ID map");
  {
    std::string id_fname = prm.get ("material id file name");
    std::ifstream in (id_fname);
    unsigned int ncell_z = dim==3?ncell_per_dir[2]:1;
    unsigned int ncell_y = dim>=2?ncell_per_dir[1]:1;
    for (unsigned int z=0; z<ncell_z; ++z)
      for (unsigned int y=0; y<ncell_y; ++y)
        for (unsigned int x=0; x<ncell_per_dir[0]; ++x)
        {
          std::vector<unsigned int> tmp {x, y, z};
          unsigned int id;
          in >> id;
          relative_position_to_id[tmp] = id - 1;
        }
    std::vector<unsigned int> tmp {1,0,0};
  }
  prm.leave_subsection ();
}

// functions used to return private member variables
template <int dim>
std::map<std::vector<unsigned int>, unsigned int>
MeshGenerator<dim>::get_id_map ()
{
  return relative_position_to_id;
}

template <int dim>
std::unordered_map<unsigned int, bool>
MeshGenerator<dim>::get_reflective_bc_map ()
{
  return is_reflective_bc;
}

template <int dim>
unsigned int MeshGenerator<dim>::get_uniform_refinement ()
{
  return global_refinements;
}

template class MeshGenerator<2>;
template class MeshGenerator<3>;
