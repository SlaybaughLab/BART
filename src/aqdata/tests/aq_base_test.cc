#include "../aq_base.h"

#include <sstream>
#include <string>

#include "gtest/gtest.h"
#include "../../test_helpers/bart_test_helper.h"

class AQBaseTest : public ::testing::Test {
 protected:
  void SetUp() override;

  template<int dim>
  void OutputAQ();

  template<int dim>
  void InitRefBCAndCheck();
  
  dealii::ParameterHandler prm;
};

void AQBaseTest::SetUp() {
  prm.declare_entry("have reflective BC", "false",
                     dealii::Patterns::Bool(), "");
  prm.declare_entry("angular quadrature order", "4",
                     dealii::Patterns::Integer(), "");
  prm.declare_entry("angular quadrature name", "gl",
                     dealii::Patterns::Selection("gl"), "");
  prm.declare_entry("number of groups", "1", dealii::Patterns::Integer(), "");
  prm.declare_entry("transport model", "regular",
                     dealii::Patterns::Selection("regular|ep"), "");
}

template<int dim>
void AQBaseTest::OutputAQ() {
  // Outputs AQData generated by MakeAQ to the deallog
  std::unique_ptr<AQBase<dim>> gl_ptr = std::make_unique<AQBase<dim>>(prm);

  gl_ptr->ProduceAQ();
  auto wi = gl_ptr->GetAQWeights();
  auto omega_i = gl_ptr->GetAQDirs();
  
  for (size_t i=0; i<wi.size(); ++i) {
    dealii::deallog << "Weight: " << wi[i] << "; Omega: ";
    for (int j=0; j<dim; ++j)
      dealii::deallog << omega_i[i][j] << " ";
    dealii::deallog << std::endl;
  }
}

template<int dim>
void AQBaseTest::InitRefBCAndCheck() {
  std::unique_ptr<AQBase<dim>> aq_base_ptr = std::make_unique<AQBase<dim>>(prm);
  aq_base_ptr->MakeAQ();
  // Get omegas and reflection map
  std::vector<dealii::Tensor<1, dim>> omegas = aq_base_ptr->GetAQDirs();
  std::map<std::pair<int, int>, int > reflection_map =
      aq_base_ptr->GetRefDirInd();

  for (auto const& mapping : reflection_map) {
    // Unroll this data structure
    int direction = mapping.first.second;
    int reflection = mapping.second;

    //x-direction
    EXPECT_FLOAT_EQ(omegas[direction][0], -omegas[reflection][0]);
  } 
}

TEST_F(AQBaseTest, AQBase1DProduceAQ) {
  std::string filename = "aq_base_1d";
  btest::GoldTestInit(filename);
  OutputAQ<1>();
  btest::GoldTestRun(filename); 
}

TEST_F(AQBaseTest, AQBase1DEpProduceAQ) {
  std::string filename = "aq_base_1d_ep";
  prm.set("transport model", "ep");
  btest::GoldTestInit(filename); // Opens deal log
  OutputAQ<1>();
  btest::GoldTestRun(filename); // Closes deal log
}

TEST_F(AQBaseTest, AQBaseBadDimProduceAQ) {
  AQBase<2> test_AQ(prm);
  ASSERT_THROW(test_AQ.ProduceAQ(), dealii::ExcMessage);
}

TEST_F(AQBaseTest, AQBaseBadDimReflectiveBC) {
  prm.set("have reflective BC", "true");
  InitRefBCAndCheck<1>();
}

TEST_F(AQBaseTest, AQBaseSNOrderGetter) {
  AQBase<1> test_AQ(prm);
  ASSERT_EQ(test_AQ.GetSnOrder(), 4);
}

TEST_F(AQBaseTest, AQBaseGetNDir) {
  AQBase<1> test_AQ(prm);
  test_AQ.MakeAQ();
  ASSERT_EQ(test_AQ.GetNDir(), 4);
}

TEST_F(AQBaseTest, AQBaseGetNDirEp) {
  prm.set("transport model", "ep");
  AQBase<1> test_AQ(prm);
  test_AQ.MakeAQ();
  ASSERT_EQ(test_AQ.GetNDir(), 2);
}

TEST_F(AQBaseTest, AQBaseGetTotalHOVars) {
  AQBase<1> test_AQ(prm);
  test_AQ.MakeAQ();
  ASSERT_EQ(test_AQ.GetNTotalHOVars(), 4);
}

TEST_F(AQBaseTest, AQBaseGetTotalHOVarsEq) {
  prm.set("transport model", "ep");
  AQBase<1> test_AQ(prm);
  test_AQ.MakeAQ();
  ASSERT_EQ(test_AQ.GetNTotalHOVars(), 2);
}

TEST_F(AQBaseTest, PrintAQ) {  
  AQBase<1> test_AQ(prm);
  test_AQ.MakeAQ();

  std::ostringstream output_string_stream;
  test_AQ.PrintAQ(&output_string_stream);

  std::string output = "transport model: regular; output_streamature name: None\n"
                       "Dim = 1, SN order = 4\n"
                       "Weights | Omega_x | Omega_y | mu\n"
                       "0.347854845137454  -0.861136311594053  \n"
                       "0.652145154862546  -0.339981043584856  \n"
                       "0.652145154862546  0.339981043584856  \n"
                       "0.347854845137454  0.861136311594053  \n"; 
  EXPECT_EQ(output, output_string_stream.str());
}
  
TEST_F(AQBaseTest, RefDirInt) {
  AQBase<1> test_AQ(prm);
  test_AQ.MakeAQ();
  std::map<std::pair<int, int>, int> component_index_map(test_AQ.GetCompInd());

  for (auto const& mapping : component_index_map) {
    EXPECT_EQ(mapping.first.first, 0);
    EXPECT_EQ(mapping.first.second, mapping.second);
  }
}

TEST_F(AQBaseTest, InvDirInd) {
  AQBase<1> test_AQ(prm);
  std::unordered_map<int, std::pair<int, int>>
      inv_component_map(test_AQ.GetInvCompInd());

  for (size_t i = 0; i < inv_component_map.size(); ++i) {
    EXPECT_EQ(inv_component_map[i].first, 0);
    EXPECT_EQ(inv_component_map[i].second, i);
  } 
}
