#include "mesh_generator.h"

#include <fstream>

#include <deal.II/grid/grid_generator.h>
#include <deal.II/grid/grid_tools.h>
#include <deal.II/grid/tria_accessor.h>
#include <deal.II/grid/tria_iterator.h>
#include <deal.II/grid/grid_in.h>

template <int dim>
MeshGenerator<dim>::MeshGenerator (dealii::ParameterHandler &prm)
    : is_mesh_generated_(prm.get_bool("is mesh generated by deal.II")),
      have_reflective_bc_(prm.get_bool("have reflective BC")),
      global_refinements_(prm.get_integer("uniform refinements")) {
  if (!is_mesh_generated_)
    mesh_filename_ = prm.get ("mesh file name");
  else {
    ProcessCoordinateInformation (prm);
    InitializeRelativePositionToIDMap (prm);
    PreprocessReflectiveBC (prm);
  }
}

template <int dim>
MeshGenerator<dim>::~MeshGenerator () {}

template <int dim>
void MeshGenerator<dim>::MakeGrid (dealii::Triangulation<dim> &tria) {
  if (is_mesh_generated_) {
    GenerateInitialGrid (tria);
    InitializeMaterialID (tria);
    SetupBoundaryIDs (tria);
    tria.refine_global (global_refinements_);
  }
  else {
    dealii::GridIn<dim> gi;
    gi.attach_triangulation (tria);
    std::ifstream f(mesh_filename_);
    gi.read_msh (f);
  }
}

template <int dim>
void MeshGenerator<dim>::GenerateInitialGrid (dealii::Triangulation<dim> &tria) {
  // Note that this function is only suitable to
  // generate a hyper rectangle, which is a line
  // in 1D, a rectangle in 2D and a rectangular
  // cuboid in 3D

  // Construction of such a rectangle requires
  dealii::Point<dim> origin;
  dealii::Point<dim> diagonal;
  switch (dim) {
    case 1: {
      diagonal[0] = axis_max_values_[0];
      break;
    }

    case 2: {
      diagonal[0] = axis_max_values_[0];
      diagonal[1] = axis_max_values_[1];
      break;
    }

    case 3: {
      diagonal[0] = axis_max_values_[0];
      diagonal[1] = axis_max_values_[1];
      diagonal[2] = axis_max_values_[2];
      break;
    }

    default:
      break;
  }
  dealii::GridGenerator::subdivided_hyper_rectangle (tria, ncell_per_dir_,
                                                     origin, diagonal);
}

template <int dim>
void MeshGenerator<dim>::InitializeMaterialID (
    dealii::Triangulation<dim> &tria) {
  AssertThrow (is_mesh_generated_==true,
               dealii::ExcMessage("mesh read in have to have boundary ids associated"));
  for (typename dealii::Triangulation<dim>::active_cell_iterator
       cell=tria.begin_active(); cell!=tria.end(); ++cell)
    if (cell->is_locally_owned()) {
      dealii::Point<dim> center = cell->center ();
      std::vector<unsigned int> relative_position (3);
      GetCellRelativePosition (center, relative_position);
      unsigned int material_id = relative_position_to_id_[relative_position];
      cell->set_material_id (material_id);
    }
}

template <int dim>
void MeshGenerator<dim>::GetCellRelativePosition (
    dealii::Point<dim> &center,
    std::vector<unsigned int> &relative_position) {
  AssertThrow (relative_position.size()==3,
               dealii::ExcMessage("relative position should be size 3 for any dimension"));
  if (dim>=1) {
    relative_position[0] =
        static_cast<unsigned int> (center[0] / cell_size_all_dir_[0]);
    if (dim>=2) {
      relative_position[1] =
          static_cast<unsigned int> (center[1] / cell_size_all_dir_[1]);
      if (dim==3)
        relative_position[2] =
            static_cast<unsigned int> (center[2] / cell_size_all_dir_[2]);
    }
  }
}

template <int dim>
void MeshGenerator<dim>::SetupBoundaryIDs
(dealii::Triangulation<dim> &tria)
{
  AssertThrow (is_mesh_generated_==true,
               dealii::ExcMessage("mesh read in have to have boundary ids associated"));
  AssertThrow (axis_max_values_.size()==dim,
               dealii::ExcMessage("number of entries axis max values should be dimension"));

  for (typename dealii::Triangulation<dim>::active_cell_iterator
       cell=tria.begin_active(); cell!=tria.end(); ++cell)
    if (cell->is_locally_owned())
      for (unsigned int fn=0; fn<dealii::GeometryInfo<dim>::faces_per_cell; ++fn)
        if (cell->at_boundary(fn)) {
          dealii::Point<dim> ct = cell->face(fn)->center();
          // x-axis boundaries
          if (std::fabs(ct[0])<1.0e-14)
            cell->face(fn)->set_boundary_id (0);
          else if (std::fabs(ct[0]-axis_max_values_[0])<1.0e-14)
            cell->face(fn)->set_boundary_id (1);

          // 2D and 3D boundaries
          if (dim>1) {
            // y-axis boundaries
            if (std::fabs(ct[1])<1.0e-14)
              cell->face(fn)->set_boundary_id (2);
            else if (std::fabs(ct[1]-axis_max_values_[1])<1.0e-14)
              cell->face(fn)->set_boundary_id (3);

            // z-axis boundaries for 3D only
            if (dim==3) {
              if (std::fabs(ct[2])<1.0e-14)
                cell->face(fn)->set_boundary_id (4);
              else if (std::fabs(ct[2]-axis_max_values_[2])<1.0e-14)
                cell->face(fn)->set_boundary_id (5);
            }
          }
        }
}

template <int dim>
void MeshGenerator<dim>::ProcessCoordinateInformation (dealii::ParameterHandler &prm)
{
  // max values for all axis
  std::vector<std::string> strings = dealii::Utilities::split_string_list (
      prm.get ("x, y, z max values of boundary locations"));
  AssertThrow (strings.size()>=dim,
               dealii::ExcMessage("Number of axis max values must be no less than dimension"));
  for (unsigned int i=0; i<dim; ++i)
    axis_max_values_.push_back (std::atof (strings[i].c_str()));

  // read in number of cells and get cell sizes along axes
  strings = dealii::Utilities::split_string_list (
      prm.get ("number of cells for x, y, z directions"));
  AssertThrow (strings.size()>=dim,
               dealii::ExcMessage ("Entries for numbers of cells must be no less than dimension"));
  std::vector<unsigned int> cells_per_dir;
  std::vector<std::vector<double> > spacings;
  for (unsigned int d=0; d<dim; ++d)
  {
    ncell_per_dir_.push_back (std::atoi (strings[d].c_str ()));
    cell_size_all_dir_.push_back (axis_max_values_[d]/ncell_per_dir_[d]);
  }
}

template <int dim>
void MeshGenerator<dim>::PreprocessReflectiveBC (dealii::ParameterHandler &prm)
{
  if (have_reflective_bc_)
  {
    std::map<std::string, unsigned int> bd_names_to_id {{"xmin",0}, {"xmax",1},
                                                        {"ymin",2}, {"ymax",3},
                                                        {"zmin",4}, {"zmax",5}};
    std::vector<std::string> strings = dealii::Utilities::split_string_list
        (prm.get ("reflective boundary names"));
    AssertThrow (strings.size()>0,
                 dealii::ExcMessage("reflective boundary names have to be entered"));
    std::set<int> tmp;
    for (unsigned int i=0; i<strings.size (); ++i)
    {
      AssertThrow(bd_names_to_id.find(strings[i])!=bd_names_to_id.end(),
                  dealii::ExcMessage("Invalid reflective boundary name: use xmin, xmax, etc."));
      tmp.insert (bd_names_to_id[strings[i]]);
    }
    auto it = tmp.begin ();
    std::ostringstream os;
    os << "No valid reflective boundary name for " << dim << "D";
    AssertThrow(*it<2*dim,
                dealii::ExcMessage(os.str()));
    for (unsigned int i=0; i<2*dim; ++i)
    {
      if (tmp.count (i))
        is_reflective_bc_[i] = true;
      else
        is_reflective_bc_[i] = false;
    }
  }
}

template <int dim>
void MeshGenerator<dim>::GetRelevantCellIterators (
  const dealii::DoFHandler<dim> &dof_handler,
  std::vector<typename dealii::DoFHandler<dim>::active_cell_iterator> &local_cells)
{
  for (typename dealii::DoFHandler<dim>::active_cell_iterator
       cell=dof_handler.begin_active();
       cell!=dof_handler.end(); ++cell)
    local_cells.push_back (cell);

}

template <int dim>
void MeshGenerator<dim>::InitializeRelativePositionToIDMap (
    dealii::ParameterHandler &prm) {
  prm.enter_subsection ("material ID map");
  {
    unsigned int ncell_z = dim==3?ncell_per_dir_[2]:1;
    unsigned int ncell_y = dim>=2?ncell_per_dir_[1]:1;
    unsigned int ncell_x = ncell_per_dir_[0];
    std::string id_fname = prm.get ("material id file name");
    std::ifstream in (id_fname);
    std::string line;
    unsigned int ct = 0;
    if (in.is_open ()) {
      while (std::getline (in, line)) {
        unsigned int y = ct % ncell_y;
        unsigned int z = ct / ncell_y;
        std::vector<std::string> strings = dealii::Utilities::split_string_list (line, ' ');
        AssertThrow (strings.size()==ncell_x,
                     dealii::ExcMessage("Entries of material ID per row must be ncell_x"));
        for (unsigned int x=0; x<ncell_x; ++x) {
          std::vector<unsigned int> tmp {x, y, z};
          relative_position_to_id_[tmp] = std::atoi (strings[x].c_str()) - 1;
        }
        ct += 1;
      }
      AssertThrow (ct==ncell_y*ncell_z,
          dealii::ExcMessage("Number of y, z ID entries are not correct"));
      in.close ();
    }
  }
  prm.leave_subsection ();
}

template <int dim>
std::unordered_map<unsigned int, bool>
MeshGenerator<dim>::GetReflectiveBCMap () {
  return is_reflective_bc_;
}

template <int dim>
unsigned int MeshGenerator<dim>::GetUniformRefinement () {
  return global_refinements_;
}

template class MeshGenerator<1>;
template class MeshGenerator<2>;
template class MeshGenerator<3>;
